<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/moon.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
	<section>
	  <h3>Living with Kubernetes</h3>

	  <img src="Kubernetes-logo.png"/>

	  <h6>Tristan Straub</h6>
	</section>

	<section>
	  <h3>Introduction</h3>
	  <ul>
	    <li>6 month project with full ci/cd pipeline</li>
	    <li>personal goal of ubiquitous compute platform</li>
	  </ul>
	</section>

	<section>
	  <h3>journey to the clouds</h3>
	  <ul>
	    <li>0. on premise, painful non-automated deploys</li>
	    <li>1. Separate dev/ops, orchestrated by hudson</li>
	    <li>2. elastic beanstalk, cattle, docker
	      <ul>
		<li>slow deploys</li>
		<li>machine per service -- over provisioning</li>
		<li>scaling isn't quick enough</li>
	      </ul>
	    </li>
	    <li>
	  </ul>
	</section>

	<section>
	  <h3>driven to find ubiquitous distributed computing platform</h3>
	  <ul>
	    <li>any hardware platform (mobile, tablet, desktop, laptop, watch)</li>
	    <li>subsets of functionality</li>
	    <li>jvm?</li>
	    <li>browser?</li>
	    <li>docker</li>
	    <li>file synchronisation, password sync</li>
	  </ul>
	</section>

	<section>
	  <h3>consul, nomad agent + nomad server</h3>
	  <ul>
	    <li>simple</li>
	    <li>declarative description of services (hcl -- hashicorp configuration language)</li>
	    <li>hashicorps other tools: terraform, packer</li>
	  </ul>
	</section>

	<section>
	  <h3>Declarative (data driven)</h3>
	  <ul>
	    <li>things we have, to things we want</li>
	    <li>yaml</li>
	    <li>hcl</li>
	    <li>html</li>
	    <li>make (almost)</li>
	  </ul>
	</section>

	<section>
	  <h3>recent project</h3>
	  <ul>
	    <li>azure, no availability zones in sydney, and only two fault domains in sydney</li>
	    <li>ci/cd</li>
	    <li>stateless compute and web services</li>
	    <li>on premise -> cloud</li>
	  </ul>
	</section>	
	
	<section>
	  <h3>infra options</h3>
	  <ul>
	    <li>terraform vs ARM</li>
	    <li>packer</li>
	  </ul>
	</section>	

	<section>
	  <h3>compute options</h3>
	  <ul>
	    <li>docker swarm (felt too slapped on)</li>
	    <li>nomad (not enough community support)</li>
	    <li>kubernetes (supported by large company, moving fast)</li>
	    <li>aws lambda, heroku -- Honourable mentions, uninvestigated</li>
	  </ul>
	</section>
	
	<section>
	  <h3>cicd/always tested/promoted builds</h3>
	  <ul>
	    <li>rails, wiki in 20 minutes, heroku push to deploy</li>
	    <li>tdd</li>
	    <li>deploy early, deploy often</li>
	    <li>master is always deployable</li>
	  </ul>
	</section>

	<section>
	  <h3>getting familiar with kubernetes -- local environments</h3>
	  <li>local dev, minikube(xhyve)</li>
	  <li>minikube</li>
	  <li>docker/osx native kubernetes</li>
	  <li>kubectl expose creates services on local ports.</li>
	</section>

	<section>
	  <h3>everything is a container -- docker</h3>
	  <ul>
	    <li>isolation: process group, network stack, file system</li>
	    <li>layered file system</li>
	    <li>provides executable documentation with the same intent as ansible, puppet, chef.</li>
	    <li>osx: host port bindings on osx dont work -- but kubernetes!</li>
	  </ul>
	</section>

	<section>
	  <h3>kubectl everything</h3>
	  <li>kubectl exec -it centos:7 -- /bin/bash</li>
	  <li>kubectl get nodes</li>
	  <li>kubectl get pods</li>
	  <li>kubectl expose...</li>
	</section>

	<section>
	  <h3>everything is yaml</h3>
	  <li>"kubectl apply -f <yaml>" all the things</li>
	</section>

	<section>
	  <h3>dashboard</h3>
	  <ul>
	    <li>kubectl proxy -> http://localhost:8001/ui</li>
	    <li>Access to all kubernetes resources</li>
	    <li>Node monitoring</li>
	    <li>Deployment monitoring</li>
	    <li>Secrets management</li>
	    <li>Configuration management</li>
	  </ul>
	</section>

	<section>
	  <img src="ui-dashboard.png"/>
	</section>

	<section>
	  <h3>remote environments</h3>
	  <ul>
	    <li>kops (aws)</li>
	    <li>acs-engine</li>

	    <li>EKS</li>
	    <li>AKS</li>
	    <li>GCE</li>

	    <li>Rancher -- honourable mention</li>
	  </ul>
	</section>

	<section>
	  <h3>kops (aws)</h3>
	  <ul>
	    <li>quick to start</li>
	    <li>played with spot instances</li>
	    <li>returning 6 months later, couldn't get it to work as a private cluster.</li>
	  </ul>
	</section>

	<section>
	  <h3>acs-engine</h3>
	  <ul>
	    <li>template engine for azure resource templates (5 minutes to come up)</li>
	    <li>terraformed external resources</li>
	    <li>version changes from 1.8.3 with classic networking then to azure CNI 1.8.4+ (own misunderstanding?)</li>
	    <li>small changes to config are time wasters (often unstable to begin with).</li>
	    <li>multi master</li>
	    <li>HA for apiserver</li>
	  </ul>
	</section>

	<section>
	  <h3>docker registry (private)</h3>
	  <ul>
	    <li>aws has per container repositories</li>
	    <li>azure has multi container repositories</li>
	  </ul>
	</section>

	<section>
	  <h3>naming deploys (unique)</h3>
	  <ul>
	    <li>config and deployments uniquely named per deploy.</li>
	    <li>services deployed once, not uniquely named.</li>
	    <li>secrets not uniquely named.</li>
	  </ul>
	</section>

	<section>
	  <h3>secrets</h3>
	  <ul>
	    <li>tmpfs</li>
	    <li>file based, or bring as environment variables.</li>
	    <li>per namespace</li>
	  </ul>
	</section>	
	
	<section>
	  <h3>kubectl proxy and the API</h3>
	  <ul>
	    <li>provided authorized access to kubernetes</li>
	    <li>used as proxy for data-config from circleci and when locally deploying.</li>
	  </ul>
	</section>

	<section>
	  <h3>service abstraction</h3>
	  <ul>
	    <li>expose pods externally.</li>		
	    <li>native load balancers -- internal/external</li>
	  </ul>
	</section>
	
	<section>
	  <h3>public master or bastion/vpn</h3>
	  <ul>
	    <li>decouple VPN from kubernetes network</li>
	    <li>machines not named uniquely</li>
	    <li>configuration finds the machines</li>
	  </ul>
	</section>	

	<section>
	  <h3>subnet design, separation of production/staging.</h3>
	  <ul>
	    <li>embedding cluster with other resources</li>
	    <li>ipv4, does kafka/cassandra work with ipv4?</li>
	    <li>subdivision, VPN, kafka, cassandra, k8s master + agent nodes.</li>
	    <li>pods are in own private network.</li>
	  </ul>
	</section>	

	<section>
	  <h3>public vs private master</h3>
	  <ul>
	    <li>kops and acs-engine created public master nodes, (with security groups)</li>
	    <li>acs-engine private cluster only became stable very recently,</li>
	    <li>could not get kops working as private cluster</li>
	  </ul>
	</section>	

	<section>
	  <h3>orchestration</h3>
	  <ul>
	    <li>Complete build and deploy in 60 minutes</li>
	    <li>Kubernetes + Kafka + Cassandra + Service builds and deploys</li>
	    <li>Docker based tooling -- cockpit</li>
	  </ul>
	</section>

	<section>
	  <h3>cockpit -- tooling</h3>
	  <ul>
	    <li>azure-cli</li>
	    <li>packer</li>
	    <li>terraform</li>
	    <li>acs-engine</li>
	    <li>kubectl</li>
	    <li>helm</li>
	    <li>docker</li>
	    <li>jq, socat, netcat, ssh, git, cqlsh, leinigen, clojure</li>
	  </ul>
	</section>

	<section>
	  <h3>circleci</h3>
	  <ul>
	    <li>github integration</li>
	    <li>custom build tooling - orchestrate container builds + deploys</li>
	    <li>per branch deploys</li>
	    <li>remote build + deploy</li>
	    <li>remote build + local deploy (staging -> prod)</li>
	    <li>data-config: Namespace, ConfigMap, Deployment, Service (not secrets)</li>
	    <li>doesn't work remote with private master (without a tunnel)</li>
	  </ul>
	</section>

	<section>
	  <h3>agent node is a shared resource (memory, cpu, network) (shared living)</h3>
	  <ul>
	    
	  </ul>
	</section>
	
	<section>
	  <h3>memory limits, jvm (kswapd), outage</h3>
	  <ul>
	    <li>make requests/limits the same</li>
	    <li>bin packing</li>
	    <li>deployments distribute evenly</li>
	    <li>cicd requires space for new pods/containers</li>
	  </ul>
	</section>

	<section>
	  <h3>config, how config naming and automatic reloading can hurt</h3>
	  <ul>
	    <li>naming configs (unique)</li>
	  </ul>
	</section>

	<section>
	  <h3>namespaces aren't enough (staging consuming production resources)</h3>
	  <ul>
	    <li>but are great</li>
	    <li>separate services</li>
	    <li>consumer same IP space</li>
	  </ul>
	</section>	

	<section>
	  <h3>Recommendations</h3>
	  <ul>
	    <li>kubernetes is a moving target (deprecated options, new networking options)</li>
	    <li>needs one full time effective just on kubernetes.</li>
	    <li>Or, use a managed service</li>
	  </ul>
	</section>	
	
	<section>
	  <h3>Further reading</h3>
	  <li>network policies</li>
	  <li>service mesh</li>
	  <li>rbac</li>
	  <li>operators for stateful services</li>
	</section>

	<section>
	  <h3>Next steps</h3>
	  <ul>
	    <li>spinnaker -- orchestration (not a build server)</li>
	    <li>jenkins, jenkinsx</li>
	    <li>rancher</li>
	  </ul>
	</section>

	<section>
	  <h3>Thank you!</h3>
	</section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
      dependencies: [
      { src: 'plugin/markdown/marked.js' },
      { src: 'plugin/markdown/markdown.js' },
      { src: 'plugin/notes/notes.js', async: true },
      { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
      ]
      });
    </script>
  </body>
</html>
